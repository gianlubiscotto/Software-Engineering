<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Coverage of boxes: functions.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Coverage of boxes
   &#160;<span id="projectnumber">1.0</span>
   </div>
   <div id="projectbrief">Documentation_about_extension_to_hypro</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">functions.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Definition of functions and operators common to multiple files.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;fstream&gt;</code><br />
<code>#include &quot;<a class="el" href="types_8h_source.html">types.h</a>&quot;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for functions.h:</div>
<div class="dyncontent">
<div class="center"><img src="functions_8h__incl.png" border="0" usemap="#functions_8h" alt=""/></div>
<!-- MAP 0 -->
</div>
</div><div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><img src="functions_8h__dep__incl.png" border="0" usemap="#functions_8hdep" alt=""/></div>
<!-- MAP 1 -->
</div>
</div>
<p><a href="functions_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ac04089c39c17f80ee4ecac5cec49cdab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a0911278bf38f271ec1915a4fff3db984">CMP</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="functions_8h.html#ac04089c39c17f80ee4ecac5cec49cdab">c_and</a> (<a class="el" href="types_8h.html#a0911278bf38f271ec1915a4fff3db984">CMP</a> c1, <a class="el" href="types_8h.html#a0911278bf38f271ec1915a4fff3db984">CMP</a> c2)</td></tr>
<tr class="memdesc:ac04089c39c17f80ee4ecac5cec49cdab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that makes logic AND between two CMP.  <a href="#ac04089c39c17f80ee4ecac5cec49cdab">More...</a><br /></td></tr>
<tr class="separator:ac04089c39c17f80ee4ecac5cec49cdab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d9ec56430ebb1fca6ac919201544d6d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a0911278bf38f271ec1915a4fff3db984">CMP</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="functions_8h.html#a9d9ec56430ebb1fca6ac919201544d6d">c_not</a> (<a class="el" href="types_8h.html#a0911278bf38f271ec1915a4fff3db984">CMP</a> c)</td></tr>
<tr class="memdesc:a9d9ec56430ebb1fca6ac919201544d6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that makes logic NOT of a CMP value.  <a href="#a9d9ec56430ebb1fca6ac919201544d6d">More...</a><br /></td></tr>
<tr class="separator:a9d9ec56430ebb1fca6ac919201544d6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7e904cbdf32b60b636053b78266b893"><td class="memTemplParams" colspan="2">template&lt;typename R &gt; </td></tr>
<tr class="memitem:ae7e904cbdf32b60b636053b78266b893"><td class="memTemplItemLeft" align="right" valign="top">R&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="functions_8h.html#ae7e904cbdf32b60b636053b78266b893">Min</a> (R i, R j)</td></tr>
<tr class="memdesc:ae7e904cbdf32b60b636053b78266b893"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that compares two numbers.  <a href="#ae7e904cbdf32b60b636053b78266b893">More...</a><br /></td></tr>
<tr class="separator:ae7e904cbdf32b60b636053b78266b893"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacd663fc8b0565990988073bd5e9d867"><td class="memTemplParams" colspan="2">template&lt;typename R &gt; </td></tr>
<tr class="memitem:aacd663fc8b0565990988073bd5e9d867"><td class="memTemplItemLeft" align="right" valign="top">R&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="functions_8h.html#aacd663fc8b0565990988073bd5e9d867">Max</a> (R i, R j)</td></tr>
<tr class="memdesc:aacd663fc8b0565990988073bd5e9d867"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that compares two numbers.  <a href="#aacd663fc8b0565990988073bd5e9d867">More...</a><br /></td></tr>
<tr class="separator:aacd663fc8b0565990988073bd5e9d867"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaf48eb9b41133609a9bcf305461adb0"><td class="memTemplParams" colspan="2">template&lt;typename R &gt; </td></tr>
<tr class="memitem:afaf48eb9b41133609a9bcf305461adb0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structPR.html">PR</a>&lt; R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="functions_8h.html#afaf48eb9b41133609a9bcf305461adb0">Min</a> (const <a class="el" href="structBR.html">BR</a>&lt; R &gt; &amp;box)</td></tr>
<tr class="memdesc:afaf48eb9b41133609a9bcf305461adb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that returns the smallest point (vertex) of a <a class="el" href="structBR.html" title="The struct which represents a box in R^d with d&gt;0, with inclusion order. ">BR</a> passed as input.  <a href="#afaf48eb9b41133609a9bcf305461adb0">More...</a><br /></td></tr>
<tr class="separator:afaf48eb9b41133609a9bcf305461adb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadc76a7a8f70f71fa6ffce8572af224b"><td class="memTemplParams" colspan="2">template&lt;typename R &gt; </td></tr>
<tr class="memitem:aadc76a7a8f70f71fa6ffce8572af224b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structPR.html">PR</a>&lt; R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="functions_8h.html#aadc76a7a8f70f71fa6ffce8572af224b">Max</a> (const <a class="el" href="structBR.html">BR</a>&lt; R &gt; &amp;box)</td></tr>
<tr class="memdesc:aadc76a7a8f70f71fa6ffce8572af224b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that returns the largest point (vertex) of a <a class="el" href="structBR.html" title="The struct which represents a box in R^d with d&gt;0, with inclusion order. ">BR</a> passed as input.  <a href="#aadc76a7a8f70f71fa6ffce8572af224b">More...</a><br /></td></tr>
<tr class="separator:aadc76a7a8f70f71fa6ffce8572af224b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abae93ee5d606cca1963e31d02d5ba27a"><td class="memTemplParams" colspan="2">template&lt;typename R &gt; </td></tr>
<tr class="memitem:abae93ee5d606cca1963e31d02d5ba27a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a8ada4b9f0d00f81484f79ef9aa0fbe74">N</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="functions_8h.html#abae93ee5d606cca1963e31d02d5ba27a">size</a> (const <a class="el" href="structU__IR.html">U_IR</a>&lt; R &gt; &amp;u_ir)</td></tr>
<tr class="memdesc:abae93ee5d606cca1963e31d02d5ba27a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that computes the size of the <a class="el" href="structU__IR.html" title="The struct which represents a union of intervals. ">U_IR</a> passed as input.  <a href="#abae93ee5d606cca1963e31d02d5ba27a">More...</a><br /></td></tr>
<tr class="separator:abae93ee5d606cca1963e31d02d5ba27a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d2242a337764ee93c6115afb6ab52c3"><td class="memTemplParams" colspan="2">template&lt;typename R &gt; </td></tr>
<tr class="memitem:a7d2242a337764ee93c6115afb6ab52c3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a8ada4b9f0d00f81484f79ef9aa0fbe74">N</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="functions_8h.html#a7d2242a337764ee93c6115afb6ab52c3">dim</a> (const <a class="el" href="structPR.html">PR</a>&lt; R &gt; &amp;point)</td></tr>
<tr class="memdesc:a7d2242a337764ee93c6115afb6ab52c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that computes the dimension of the <a class="el" href="structPR.html" title="The struct which represents a point. ">PR</a> passed as input.  <a href="#a7d2242a337764ee93c6115afb6ab52c3">More...</a><br /></td></tr>
<tr class="separator:a7d2242a337764ee93c6115afb6ab52c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17771fa32f75bef6521859c805c7fd6d"><td class="memTemplParams" colspan="2">template&lt;typename R &gt; </td></tr>
<tr class="memitem:a17771fa32f75bef6521859c805c7fd6d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a8ada4b9f0d00f81484f79ef9aa0fbe74">N</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="functions_8h.html#a17771fa32f75bef6521859c805c7fd6d">dim</a> (const <a class="el" href="structBR.html">BR</a>&lt; R &gt; &amp;box)</td></tr>
<tr class="memdesc:a17771fa32f75bef6521859c805c7fd6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that computes the dimension of the <a class="el" href="structBR.html" title="The struct which represents a box in R^d with d&gt;0, with inclusion order. ">BR</a> passed as input.  <a href="#a17771fa32f75bef6521859c805c7fd6d">More...</a><br /></td></tr>
<tr class="separator:a17771fa32f75bef6521859c805c7fd6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabfa1069209d27c327dd9960cbdbda58"><td class="memTemplParams" colspan="2">template&lt;typename R &gt; </td></tr>
<tr class="memitem:aabfa1069209d27c327dd9960cbdbda58"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="functions_8h.html#aabfa1069209d27c327dd9960cbdbda58">operator==</a> (const <a class="el" href="structIR.html">IR</a>&lt; R &gt; &amp;I1, const <a class="el" href="structIR.html">IR</a>&lt; R &gt; &amp;I2)</td></tr>
<tr class="memdesc:aabfa1069209d27c327dd9960cbdbda58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator for two <a class="el" href="structIR.html" title="The struct which represents an interval. ">IR</a>.  <a href="#aabfa1069209d27c327dd9960cbdbda58">More...</a><br /></td></tr>
<tr class="separator:aabfa1069209d27c327dd9960cbdbda58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af059a110629e403ca09be3c366f035d5"><td class="memTemplParams" colspan="2">template&lt;typename R &gt; </td></tr>
<tr class="memitem:af059a110629e403ca09be3c366f035d5"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="functions_8h.html#af059a110629e403ca09be3c366f035d5">operator==</a> (const <a class="el" href="structU__IR.html">U_IR</a>&lt; R &gt; &amp;u_ir1, const <a class="el" href="structU__IR.html">U_IR</a>&lt; R &gt; &amp;u_ir2)</td></tr>
<tr class="memdesc:af059a110629e403ca09be3c366f035d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator for two <a class="el" href="structU__IR.html" title="The struct which represents a union of intervals. ">U_IR</a>.  <a href="#af059a110629e403ca09be3c366f035d5">More...</a><br /></td></tr>
<tr class="separator:af059a110629e403ca09be3c366f035d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7d9c096caf494d6e0eb6a5d3bbf440c"><td class="memTemplParams" colspan="2">template&lt;typename R &gt; </td></tr>
<tr class="memitem:aa7d9c096caf494d6e0eb6a5d3bbf440c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="functions_8h.html#aa7d9c096caf494d6e0eb6a5d3bbf440c">operator==</a> (const <a class="el" href="structPR.html">PR</a>&lt; R &gt; &amp;point1, const <a class="el" href="structPR.html">PR</a>&lt; R &gt; &amp;point2)</td></tr>
<tr class="memdesc:aa7d9c096caf494d6e0eb6a5d3bbf440c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator for two <a class="el" href="structPR.html" title="The struct which represents a point. ">PR</a>.  <a href="#aa7d9c096caf494d6e0eb6a5d3bbf440c">More...</a><br /></td></tr>
<tr class="separator:aa7d9c096caf494d6e0eb6a5d3bbf440c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29015a187a109737960c8f7a9c85b997"><td class="memTemplParams" colspan="2">template&lt;typename R &gt; </td></tr>
<tr class="memitem:a29015a187a109737960c8f7a9c85b997"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="functions_8h.html#a29015a187a109737960c8f7a9c85b997">operator==</a> (const <a class="el" href="structBR.html">BR</a>&lt; R &gt; &amp;box1, const <a class="el" href="structBR.html">BR</a>&lt; R &gt; &amp;box2)</td></tr>
<tr class="memdesc:a29015a187a109737960c8f7a9c85b997"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator for two <a class="el" href="structBR.html" title="The struct which represents a box in R^d with d&gt;0, with inclusion order. ">BR</a>.  <a href="#a29015a187a109737960c8f7a9c85b997">More...</a><br /></td></tr>
<tr class="separator:a29015a187a109737960c8f7a9c85b997"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f4a4940d4cc830b71bb047ec8173475"><td class="memTemplParams" colspan="2">template&lt;typename R &gt; </td></tr>
<tr class="memitem:a3f4a4940d4cc830b71bb047ec8173475"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="functions_8h.html#a3f4a4940d4cc830b71bb047ec8173475">operator&lt;=</a> (const <a class="el" href="structIR.html">IR</a>&lt; R &gt; &amp;, const <a class="el" href="structIR.html">IR</a>&lt; R &gt; &amp;)</td></tr>
<tr class="memdesc:a3f4a4940d4cc830b71bb047ec8173475"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator for inclusion between two <a class="el" href="structIR.html" title="The struct which represents an interval. ">IR</a>.  <a href="#a3f4a4940d4cc830b71bb047ec8173475">More...</a><br /></td></tr>
<tr class="separator:a3f4a4940d4cc830b71bb047ec8173475"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48b0186996a23af195b7fbafcf423ee1"><td class="memTemplParams" colspan="2">template&lt;typename R &gt; </td></tr>
<tr class="memitem:a48b0186996a23af195b7fbafcf423ee1"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="functions_8h.html#a48b0186996a23af195b7fbafcf423ee1">operator&lt;=</a> (const <a class="el" href="structU__IR.html">U_IR</a>&lt; R &gt; &amp;, const <a class="el" href="structU__IR.html">U_IR</a>&lt; R &gt; &amp;)</td></tr>
<tr class="memdesc:a48b0186996a23af195b7fbafcf423ee1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator for inclusion between two <a class="el" href="structU__IR.html" title="The struct which represents a union of intervals. ">U_IR</a>.  <a href="#a48b0186996a23af195b7fbafcf423ee1">More...</a><br /></td></tr>
<tr class="separator:a48b0186996a23af195b7fbafcf423ee1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0bf9474c47d7d8e6e34644710323df8"><td class="memTemplParams" colspan="2">template&lt;typename R &gt; </td></tr>
<tr class="memitem:ae0bf9474c47d7d8e6e34644710323df8"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="functions_8h.html#ae0bf9474c47d7d8e6e34644710323df8">operator&lt;=</a> (const <a class="el" href="structBR.html">BR</a>&lt; R &gt; &amp;X1, const <a class="el" href="structBR.html">BR</a>&lt; R &gt; &amp;X2)</td></tr>
<tr class="memdesc:ae0bf9474c47d7d8e6e34644710323df8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator for inclusion between two <a class="el" href="structBR.html" title="The struct which represents a box in R^d with d&gt;0, with inclusion order. ">BR</a>.  <a href="#ae0bf9474c47d7d8e6e34644710323df8">More...</a><br /></td></tr>
<tr class="separator:ae0bf9474c47d7d8e6e34644710323df8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add73ad53c2502d601f59998ead4d3314"><td class="memTemplParams" colspan="2">template&lt;typename R &gt; </td></tr>
<tr class="memitem:add73ad53c2502d601f59998ead4d3314"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="functions_8h.html#add73ad53c2502d601f59998ead4d3314">operator&lt;=</a> (const <a class="el" href="structIR.html">IR</a>&lt; R &gt; &amp;I, const <a class="el" href="structU__IR.html">U_IR</a>&lt; R &gt; &amp;U)</td></tr>
<tr class="memdesc:add73ad53c2502d601f59998ead4d3314"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator for coverage of an <a class="el" href="structIR.html" title="The struct which represents an interval. ">IR</a> by a <a class="el" href="structU__IR.html" title="The struct which represents a union of intervals. ">U_IR</a>.  <a href="#add73ad53c2502d601f59998ead4d3314">More...</a><br /></td></tr>
<tr class="separator:add73ad53c2502d601f59998ead4d3314"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1c1d4c56c28a543a0e857b75280d39a"><td class="memTemplParams" colspan="2">template&lt;typename R &gt; </td></tr>
<tr class="memitem:aa1c1d4c56c28a543a0e857b75280d39a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="functions_8h.html#aa1c1d4c56c28a543a0e857b75280d39a">cmp_a</a> (const <a class="el" href="structIR.html">IR</a>&lt; R &gt; &amp;, const <a class="el" href="structIR.html">IR</a>&lt; R &gt; &amp;, <a class="el" href="types_8h.html#a0911278bf38f271ec1915a4fff3db984">CMP</a> &amp;c)</td></tr>
<tr class="memdesc:aa1c1d4c56c28a543a0e857b75280d39a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the <a class="el" href="functions_8h.html#ac04089c39c17f80ee4ecac5cec49cdab" title="Function that makes logic AND between two CMP. ">c_and()</a> between the result of comparison between two <a class="el" href="structIR.html" title="The struct which represents an interval. ">IR</a> and CMP passed as parameter.  <a href="#aa1c1d4c56c28a543a0e857b75280d39a">More...</a><br /></td></tr>
<tr class="separator:aa1c1d4c56c28a543a0e857b75280d39a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a160940345aec02499bd6e7d14062a082"><td class="memTemplParams" colspan="2">template&lt;typename R &gt; </td></tr>
<tr class="memitem:a160940345aec02499bd6e7d14062a082"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="functions_8h.html#a160940345aec02499bd6e7d14062a082">cmp_a</a> (const <a class="el" href="structU__IR.html">U_IR</a>&lt; R &gt; &amp;, const <a class="el" href="structU__IR.html">U_IR</a>&lt; R &gt; &amp;, <a class="el" href="types_8h.html#a0911278bf38f271ec1915a4fff3db984">CMP</a> &amp;c)</td></tr>
<tr class="memdesc:a160940345aec02499bd6e7d14062a082"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the <a class="el" href="functions_8h.html#ac04089c39c17f80ee4ecac5cec49cdab" title="Function that makes logic AND between two CMP. ">c_and()</a> between the result of comparison between two <a class="el" href="structU__IR.html" title="The struct which represents a union of intervals. ">U_IR</a> and CMP passed as parameter.  <a href="#a160940345aec02499bd6e7d14062a082">More...</a><br /></td></tr>
<tr class="separator:a160940345aec02499bd6e7d14062a082"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fc6cf16f02dbae15ce37486a1faf115"><td class="memTemplParams" colspan="2">template&lt;typename R &gt; </td></tr>
<tr class="memitem:a1fc6cf16f02dbae15ce37486a1faf115"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="functions_8h.html#a1fc6cf16f02dbae15ce37486a1faf115">cmp_a</a> (const <a class="el" href="structBR.html">BR</a>&lt; R &gt; &amp;, const <a class="el" href="structBR.html">BR</a>&lt; R &gt; &amp;, <a class="el" href="types_8h.html#a0911278bf38f271ec1915a4fff3db984">CMP</a> &amp;c)</td></tr>
<tr class="memdesc:a1fc6cf16f02dbae15ce37486a1faf115"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the <a class="el" href="functions_8h.html#ac04089c39c17f80ee4ecac5cec49cdab" title="Function that makes logic AND between two CMP. ">c_and()</a> between the result of comparison between two <a class="el" href="structBR.html" title="The struct which represents a box in R^d with d&gt;0, with inclusion order. ">BR</a> and CMP passed as parameter.  <a href="#a1fc6cf16f02dbae15ce37486a1faf115">More...</a><br /></td></tr>
<tr class="separator:a1fc6cf16f02dbae15ce37486a1faf115"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dc04b42c730db78aeb2a907cbce7b54"><td class="memTemplParams" colspan="2">template&lt;typename R &gt; </td></tr>
<tr class="memitem:a0dc04b42c730db78aeb2a907cbce7b54"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="functions_8h.html#a0dc04b42c730db78aeb2a907cbce7b54">add</a> (<a class="el" href="structU__IR.html">U_IR</a>&lt; R &gt; &amp;U, const <a class="el" href="structIR.html">IR</a>&lt; R &gt; &amp;I)</td></tr>
<tr class="memdesc:a0dc04b42c730db78aeb2a907cbce7b54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that adds an <a class="el" href="structIR.html" title="The struct which represents an interval. ">IR</a> to a <a class="el" href="structU__IR.html" title="The struct which represents a union of intervals. ">U_IR</a>.  <a href="#a0dc04b42c730db78aeb2a907cbce7b54">More...</a><br /></td></tr>
<tr class="separator:a0dc04b42c730db78aeb2a907cbce7b54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57e7510891ab0cf3ddec16963dab20d5"><td class="memTemplParams" colspan="2">template&lt;typename R &gt; </td></tr>
<tr class="memitem:a57e7510891ab0cf3ddec16963dab20d5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structU__IR.html">U_IR</a>&lt; R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="functions_8h.html#a57e7510891ab0cf3ddec16963dab20d5">operator+</a> (const <a class="el" href="structU__IR.html">U_IR</a>&lt; R &gt; &amp;, const <a class="el" href="structU__IR.html">U_IR</a>&lt; R &gt; &amp;)</td></tr>
<tr class="memdesc:a57e7510891ab0cf3ddec16963dab20d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator for binary union of <a class="el" href="structU__IR.html" title="The struct which represents a union of intervals. ">U_IR</a>.  <a href="#a57e7510891ab0cf3ddec16963dab20d5">More...</a><br /></td></tr>
<tr class="separator:a57e7510891ab0cf3ddec16963dab20d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e46026f597b78f907c7b02b4fd231b9"><td class="memTemplParams" colspan="2">template&lt;typename R &gt; </td></tr>
<tr class="memitem:a3e46026f597b78f907c7b02b4fd231b9"><td class="memTemplItemLeft" align="right" valign="top">ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="functions_8h.html#a3e46026f597b78f907c7b02b4fd231b9">operator&lt;&lt;</a> (ostream &amp;, const <a class="el" href="structIR.html">IR</a>&lt; R &gt; &amp;I)</td></tr>
<tr class="memdesc:a3e46026f597b78f907c7b02b4fd231b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print operator for <a class="el" href="structIR.html" title="The struct which represents an interval. ">IR</a>.  <a href="#a3e46026f597b78f907c7b02b4fd231b9">More...</a><br /></td></tr>
<tr class="separator:a3e46026f597b78f907c7b02b4fd231b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe7c2718cd8023ce4aa7b22fa12abaab"><td class="memTemplParams" colspan="2">template&lt;typename R &gt; </td></tr>
<tr class="memitem:afe7c2718cd8023ce4aa7b22fa12abaab"><td class="memTemplItemLeft" align="right" valign="top">ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="functions_8h.html#afe7c2718cd8023ce4aa7b22fa12abaab">operator&lt;&lt;</a> (ostream &amp;, const <a class="el" href="structU__IR.html">U_IR</a>&lt; R &gt; &amp;U)</td></tr>
<tr class="memdesc:afe7c2718cd8023ce4aa7b22fa12abaab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print operator for <a class="el" href="structU__IR.html" title="The struct which represents a union of intervals. ">U_IR</a>.  <a href="#afe7c2718cd8023ce4aa7b22fa12abaab">More...</a><br /></td></tr>
<tr class="separator:afe7c2718cd8023ce4aa7b22fa12abaab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada475e89fa97da10bc5d1b591fdc2e6b"><td class="memTemplParams" colspan="2">template&lt;typename R &gt; </td></tr>
<tr class="memitem:ada475e89fa97da10bc5d1b591fdc2e6b"><td class="memTemplItemLeft" align="right" valign="top">ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="functions_8h.html#ada475e89fa97da10bc5d1b591fdc2e6b">operator&lt;&lt;</a> (ostream &amp;, const <a class="el" href="structBR.html">BR</a>&lt; R &gt; &amp;box)</td></tr>
<tr class="memdesc:ada475e89fa97da10bc5d1b591fdc2e6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print operator for <a class="el" href="structBR.html" title="The struct which represents a box in R^d with d&gt;0, with inclusion order. ">BR</a>.  <a href="#ada475e89fa97da10bc5d1b591fdc2e6b">More...</a><br /></td></tr>
<tr class="separator:ada475e89fa97da10bc5d1b591fdc2e6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Definition of functions and operators common to multiple files. </p>
<dl class="section author"><dt>Author</dt><dd>E.Moggi </dd>
<dd>
G.Ceccoli </dd></dl>

<p>Definition in file <a class="el" href="functions_8h_source.html">functions.h</a>.</p>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a0dc04b42c730db78aeb2a907cbce7b54"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structU__IR.html">U_IR</a>&lt; R &gt; &amp;&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structIR.html">IR</a>&lt; R &gt; &amp;&#160;</td>
          <td class="paramname"><em>I</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that adds an <a class="el" href="structIR.html" title="The struct which represents an interval. ">IR</a> to a <a class="el" href="structU__IR.html" title="The struct which represents a union of intervals. ">U_IR</a>. </p>
<p>It selects the right index of <a class="el" href="structU__IR.html#a883ee0578b3efb742f7680259f35646e">U_IR::S</a> where <a class="el" href="structIR.html" title="The struct which represents an interval. ">IR</a> should be placed and if not present it adds it. If the new <a class="el" href="structIR.html" title="The struct which represents an interval. ">IR</a> connects two previous disjoint <a class="el" href="structIR.html" title="The struct which represents an interval. ">IR</a> the three <a class="el" href="structIR.html" title="The struct which represents an interval. ">IR</a> merges into one. If the new <a class="el" href="structIR.html" title="The struct which represents an interval. ">IR</a> extends a previous <a class="el" href="structIR.html" title="The struct which represents an interval. ">IR</a> they merge into one <a class="el" href="structIR.html" title="The struct which represents an interval. ">IR</a> as well. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">U</td><td>the <a class="el" href="structU__IR.html" title="The struct which represents a union of intervals. ">U_IR</a> to which to add the <a class="el" href="structIR.html" title="The struct which represents an interval. ">IR</a>. </td></tr>
    <tr><td class="paramname">I</td><td>the <a class="el" href="structIR.html" title="The struct which represents an interval. ">IR</a> to add. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac04089c39c17f80ee4ecac5cec49cdab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a0911278bf38f271ec1915a4fff3db984">CMP</a> c_and </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="types_8h.html#a0911278bf38f271ec1915a4fff3db984">CMP</a>&#160;</td>
          <td class="paramname"><em>c1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#a0911278bf38f271ec1915a4fff3db984">CMP</a>&#160;</td>
          <td class="paramname"><em>c2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that makes logic AND between two CMP. </p>
<p>If c1 or c2 has value "equal" it returns the other. If one of them has value "not comparable" it returns "not comparable". If c1==c2 it returns c1. If c1 ad c2 have different values ("less then" and "greater then") it returns "not comparable". </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c1</td><td>The first CMP value. </td></tr>
    <tr><td class="paramname">c2</td><td>The second CMP value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMP The result of AND operation. </dd></dl>

</div>
</div>
<a class="anchor" id="a9d9ec56430ebb1fca6ac919201544d6d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a0911278bf38f271ec1915a4fff3db984">CMP</a> c_not </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="types_8h.html#a0911278bf38f271ec1915a4fff3db984">CMP</a>&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that makes logic NOT of a CMP value. </p>
<p>NOT("less than")="greater than". NOT("greater than")="less than". NOT("equal")="equal". NOT("not comparable")="not comparable". </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>The CMP value on which perform NOT operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMP The result of NOT operation. </dd></dl>

</div>
</div>
<a class="anchor" id="aa1c1d4c56c28a543a0e857b75280d39a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void cmp_a </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structIR.html">IR</a>&lt; R &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structIR.html">IR</a>&lt; R &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#a0911278bf38f271ec1915a4fff3db984">CMP</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs the <a class="el" href="functions_8h.html#ac04089c39c17f80ee4ecac5cec49cdab" title="Function that makes logic AND between two CMP. ">c_and()</a> between the result of comparison between two <a class="el" href="structIR.html" title="The struct which represents an interval. ">IR</a> and CMP passed as parameter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">I1</td><td>The first <a class="el" href="structIR.html" title="The struct which represents an interval. ">IR</a>. </td></tr>
    <tr><td class="paramname">I2</td><td>The second <a class="el" href="structIR.html" title="The struct which represents an interval. ">IR</a>. </td></tr>
    <tr><td class="paramname">c</td><td>The CMP with which perform <a class="el" href="functions_8h.html#ac04089c39c17f80ee4ecac5cec49cdab" title="Function that makes logic AND between two CMP. ">c_and()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a160940345aec02499bd6e7d14062a082"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void cmp_a </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structU__IR.html">U_IR</a>&lt; R &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structU__IR.html">U_IR</a>&lt; R &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#a0911278bf38f271ec1915a4fff3db984">CMP</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs the <a class="el" href="functions_8h.html#ac04089c39c17f80ee4ecac5cec49cdab" title="Function that makes logic AND between two CMP. ">c_and()</a> between the result of comparison between two <a class="el" href="structU__IR.html" title="The struct which represents a union of intervals. ">U_IR</a> and CMP passed as parameter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">U1</td><td>The first <a class="el" href="structU__IR.html" title="The struct which represents a union of intervals. ">U_IR</a>. </td></tr>
    <tr><td class="paramname">U2</td><td>The second <a class="el" href="structU__IR.html" title="The struct which represents a union of intervals. ">U_IR</a>. </td></tr>
    <tr><td class="paramname">c</td><td>The CMP with which perform <a class="el" href="functions_8h.html#ac04089c39c17f80ee4ecac5cec49cdab" title="Function that makes logic AND between two CMP. ">c_and()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1fc6cf16f02dbae15ce37486a1faf115"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void cmp_a </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structBR.html">BR</a>&lt; R &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structBR.html">BR</a>&lt; R &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#a0911278bf38f271ec1915a4fff3db984">CMP</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs the <a class="el" href="functions_8h.html#ac04089c39c17f80ee4ecac5cec49cdab" title="Function that makes logic AND between two CMP. ">c_and()</a> between the result of comparison between two <a class="el" href="structBR.html" title="The struct which represents a box in R^d with d&gt;0, with inclusion order. ">BR</a> and CMP passed as parameter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">B1</td><td>The first <a class="el" href="structBR.html" title="The struct which represents a box in R^d with d&gt;0, with inclusion order. ">BR</a>. </td></tr>
    <tr><td class="paramname">B2</td><td>The second <a class="el" href="structBR.html" title="The struct which represents a box in R^d with d&gt;0, with inclusion order. ">BR</a>. </td></tr>
    <tr><td class="paramname">c</td><td>The CMP with which perform <a class="el" href="functions_8h.html#ac04089c39c17f80ee4ecac5cec49cdab" title="Function that makes logic AND between two CMP. ">c_and()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7d2242a337764ee93c6115afb6ab52c3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a8ada4b9f0d00f81484f79ef9aa0fbe74">N</a> dim </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structPR.html">PR</a>&lt; R &gt; &amp;&#160;</td>
          <td class="paramname"><em>point</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that computes the dimension of the <a class="el" href="structPR.html" title="The struct which represents a point. ">PR</a> passed as input. </p>
<p>The dimension is computed by counting how many coordinates form the point. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">point</td><td>The <a class="el" href="structPR.html" title="The struct which represents a point. ">PR</a> passed as input. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="types_8h.html#a8ada4b9f0d00f81484f79ef9aa0fbe74" title="Typedef for unsigned int.  It represents a link to a node/leaf inside DAG. ">N</a> The size of <a class="el" href="structPR.html#a2676bb41b232def82358ae40311064a3">PR::x</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a17771fa32f75bef6521859c805c7fd6d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a8ada4b9f0d00f81484f79ef9aa0fbe74">N</a> dim </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structBR.html">BR</a>&lt; R &gt; &amp;&#160;</td>
          <td class="paramname"><em>box</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that computes the dimension of the <a class="el" href="structBR.html" title="The struct which represents a box in R^d with d&gt;0, with inclusion order. ">BR</a> passed as input. </p>
<p>The dimension is computed by counting how many <a class="el" href="structIR.html" title="The struct which represents an interval. ">IR</a> form the <a class="el" href="structBR.html" title="The struct which represents a box in R^d with d&gt;0, with inclusion order. ">BR</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">box</td><td>The <a class="el" href="structBR.html" title="The struct which represents a box in R^d with d&gt;0, with inclusion order. ">BR</a> passed as input. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="types_8h.html#a8ada4b9f0d00f81484f79ef9aa0fbe74" title="Typedef for unsigned int.  It represents a link to a node/leaf inside DAG. ">N</a> The size of <a class="el" href="structBR.html#a8e9cef9c38b306952fe679536962d868">BR::x</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="aacd663fc8b0565990988073bd5e9d867"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">R Max </td>
          <td>(</td>
          <td class="paramtype">R&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that compares two numbers. </p>
<p>It returns the largest value between the two passed as parameters </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The first value. </td></tr>
    <tr><td class="paramname">j</td><td>The second value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>The used number type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>R The largest between the two. </dd></dl>

</div>
</div>
<a class="anchor" id="aadc76a7a8f70f71fa6ffce8572af224b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structPR.html">PR</a>&lt;R&gt; Max </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structBR.html">BR</a>&lt; R &gt; &amp;&#160;</td>
          <td class="paramname"><em>box</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that returns the largest point (vertex) of a <a class="el" href="structBR.html" title="The struct which represents a box in R^d with d&gt;0, with inclusion order. ">BR</a> passed as input. </p>
<p>The largest vertex is computed by collecting all the upper values of each <a class="el" href="structIR.html" title="The struct which represents an interval. ">IR</a> in each dimension of the <a class="el" href="structBR.html" title="The struct which represents a box in R^d with d&gt;0, with inclusion order. ">BR</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Box</td><td>The <a class="el" href="structBR.html" title="The struct which represents a box in R^d with d&gt;0, with inclusion order. ">BR</a> passed as input. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structPR.html" title="The struct which represents a point. ">PR</a> The largest vertex of the <a class="el" href="structBR.html" title="The struct which represents a box in R^d with d&gt;0, with inclusion order. ">BR</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="ae7e904cbdf32b60b636053b78266b893"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">R Min </td>
          <td>(</td>
          <td class="paramtype">R&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that compares two numbers. </p>
<p>It returns the smallest value between the two passed as parameters </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The first value. </td></tr>
    <tr><td class="paramname">j</td><td>The second value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>The used number type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>R The smallest between the two. </dd></dl>

</div>
</div>
<a class="anchor" id="afaf48eb9b41133609a9bcf305461adb0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structPR.html">PR</a>&lt;R&gt; Min </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structBR.html">BR</a>&lt; R &gt; &amp;&#160;</td>
          <td class="paramname"><em>box</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that returns the smallest point (vertex) of a <a class="el" href="structBR.html" title="The struct which represents a box in R^d with d&gt;0, with inclusion order. ">BR</a> passed as input. </p>
<p>The smallest vertex is computed by collecting all the lower values of each <a class="el" href="structIR.html" title="The struct which represents an interval. ">IR</a> in each dimension of the <a class="el" href="structBR.html" title="The struct which represents a box in R^d with d&gt;0, with inclusion order. ">BR</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Box</td><td>The <a class="el" href="structBR.html" title="The struct which represents a box in R^d with d&gt;0, with inclusion order. ">BR</a> passed as input. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structPR.html" title="The struct which represents a point. ">PR</a> The smallest vertex of the <a class="el" href="structBR.html" title="The struct which represents a box in R^d with d&gt;0, with inclusion order. ">BR</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a57e7510891ab0cf3ddec16963dab20d5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structU__IR.html">U_IR</a>&lt;R&gt; operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structU__IR.html">U_IR</a>&lt; R &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structU__IR.html">U_IR</a>&lt; R &gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Operator for binary union of <a class="el" href="structU__IR.html" title="The struct which represents a union of intervals. ">U_IR</a>. </p>
<p>It scans both <a class="el" href="structU__IR.html" title="The struct which represents a union of intervals. ">U_IR</a> merging they're <a class="el" href="structIR.html" title="The struct which represents an interval. ">IR</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">U1</td><td>the first <a class="el" href="structU__IR.html" title="The struct which represents a union of intervals. ">U_IR</a>. </td></tr>
    <tr><td class="paramname">U2</td><td>the second <a class="el" href="structU__IR.html" title="The struct which represents a union of intervals. ">U_IR</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structU__IR.html" title="The struct which represents a union of intervals. ">U_IR</a> A new <a class="el" href="structU__IR.html" title="The struct which represents a union of intervals. ">U_IR</a> containing the union of the two <a class="el" href="structU__IR.html" title="The struct which represents a union of intervals. ">U_IR</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a3e46026f597b78f907c7b02b4fd231b9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ostream&amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structIR.html">IR</a>&lt; R &gt; &amp;&#160;</td>
          <td class="paramname"><em>I</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print operator for <a class="el" href="structIR.html" title="The struct which represents an interval. ">IR</a>. </p>
<p>It makes possible to print out an <a class="el" href="structIR.html" title="The struct which represents an interval. ">IR</a> in the form: [<a class="el" href="structIR.html#af9d1bea208e91beb8b3fd9bbd62655ff">IR::l</a>,<a class="el" href="structIR.html#a3f78c20104f8007d10068450dfef428b">IR::u</a>] </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">I</td><td>the <a class="el" href="structIR.html" title="The struct which represents an interval. ">IR</a> to print. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afe7c2718cd8023ce4aa7b22fa12abaab"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ostream&amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structU__IR.html">U_IR</a>&lt; R &gt; &amp;&#160;</td>
          <td class="paramname"><em>U</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print operator for <a class="el" href="structU__IR.html" title="The struct which represents a union of intervals. ">U_IR</a>. </p>
<p>It makes possible to print out the sequence of disjoint <a class="el" href="structIR.html" title="The struct which represents an interval. ">IR</a> in the form: [<a class="el" href="structIR.html#af9d1bea208e91beb8b3fd9bbd62655ff">IR::l</a>,<a class="el" href="structIR.html#a3f78c20104f8007d10068450dfef428b">IR::u</a>]+[<a class="el" href="structIR.html#af9d1bea208e91beb8b3fd9bbd62655ff">IR::l</a>,<a class="el" href="structIR.html#a3f78c20104f8007d10068450dfef428b">IR::u</a>] </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">U</td><td>the <a class="el" href="structU__IR.html" title="The struct which represents a union of intervals. ">U_IR</a> to print. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ada475e89fa97da10bc5d1b591fdc2e6b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ostream&amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structBR.html">BR</a>&lt; R &gt; &amp;&#160;</td>
          <td class="paramname"><em>box</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print operator for <a class="el" href="structBR.html" title="The struct which represents a box in R^d with d&gt;0, with inclusion order. ">BR</a>. </p>
<p>It makes possible to print out a <a class="el" href="structBR.html" title="The struct which represents a box in R^d with d&gt;0, with inclusion order. ">BR</a> in form of a cartesian product: [<a class="el" href="structIR.html#af9d1bea208e91beb8b3fd9bbd62655ff">IR::l</a>,<a class="el" href="structIR.html#a3f78c20104f8007d10068450dfef428b">IR::u</a>]x[<a class="el" href="structIR.html#af9d1bea208e91beb8b3fd9bbd62655ff">IR::l</a>,<a class="el" href="structIR.html#a3f78c20104f8007d10068450dfef428b">IR::u</a>]x...x[<a class="el" href="structIR.html#af9d1bea208e91beb8b3fd9bbd62655ff">IR::l</a>,<a class="el" href="structIR.html#a3f78c20104f8007d10068450dfef428b">IR::u</a>] </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">box</td><td>the <a class="el" href="structBR.html" title="The struct which represents a box in R^d with d&gt;0, with inclusion order. ">BR</a> to print. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3f4a4940d4cc830b71bb047ec8173475"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structIR.html">IR</a>&lt; R &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structIR.html">IR</a>&lt; R &gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Operator for inclusion between two <a class="el" href="structIR.html" title="The struct which represents an interval. ">IR</a>. </p>
<p>An <a class="el" href="structIR.html" title="The struct which represents an interval. ">IR</a> X1 is included in another if the second contains the lower and upper limits of the first. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">X1</td><td>the first <a class="el" href="structIR.html" title="The struct which represents an interval. ">IR</a>. </td></tr>
    <tr><td class="paramname">X2</td><td>the second <a class="el" href="structIR.html" title="The struct which represents an interval. ">IR</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if X2.l&lt;=X1.l&lt;=X1.u&lt;=X2.u, false otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="a48b0186996a23af195b7fbafcf423ee1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structU__IR.html">U_IR</a>&lt; R &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structU__IR.html">U_IR</a>&lt; R &gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Operator for inclusion between two <a class="el" href="structU__IR.html" title="The struct which represents a union of intervals. ">U_IR</a>. </p>
<p>A <a class="el" href="structU__IR.html" title="The struct which represents a union of intervals. ">U_IR</a> X1 is included in another if the second includes all the <a class="el" href="structIR.html" title="The struct which represents an interval. ">IR</a> of first. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">X1</td><td>the first <a class="el" href="structU__IR.html" title="The struct which represents a union of intervals. ">U_IR</a>. </td></tr>
    <tr><td class="paramname">X2</td><td>the second <a class="el" href="structU__IR.html" title="The struct which represents a union of intervals. ">U_IR</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if every <a class="el" href="structIR.html" title="The struct which represents an interval. ">IR</a> of X1 is included in any <a class="el" href="structIR.html" title="The struct which represents an interval. ">IR</a> of X2. </dd></dl>

</div>
</div>
<a class="anchor" id="ae0bf9474c47d7d8e6e34644710323df8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structBR.html">BR</a>&lt; R &gt; &amp;&#160;</td>
          <td class="paramname"><em>X1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structBR.html">BR</a>&lt; R &gt; &amp;&#160;</td>
          <td class="paramname"><em>X2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Operator for inclusion between two <a class="el" href="structBR.html" title="The struct which represents a box in R^d with d&gt;0, with inclusion order. ">BR</a>. </p>
<p>A <a class="el" href="structBR.html" title="The struct which represents a box in R^d with d&gt;0, with inclusion order. ">BR</a> X1 is included in another if each <a class="el" href="structIR.html" title="The struct which represents an interval. ">IR</a> of the second includes each <a class="el" href="structIR.html" title="The struct which represents an interval. ">IR</a> of the first. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">X1</td><td>the first <a class="el" href="structBR.html" title="The struct which represents a box in R^d with d&gt;0, with inclusion order. ">BR</a>. </td></tr>
    <tr><td class="paramname">X2</td><td>the second <a class="el" href="structBR.html" title="The struct which represents a box in R^d with d&gt;0, with inclusion order. ">BR</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if, for every dimension, the <a class="el" href="structIR.html" title="The struct which represents an interval. ">IR</a> of X1 related to that dimension is included in the <a class="el" href="structIR.html" title="The struct which represents an interval. ">IR</a> related to the same dimension of X2, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="add73ad53c2502d601f59998ead4d3314"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structIR.html">IR</a>&lt; R &gt; &amp;&#160;</td>
          <td class="paramname"><em>I</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structU__IR.html">U_IR</a>&lt; R &gt; &amp;&#160;</td>
          <td class="paramname"><em>U</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Operator for coverage of an <a class="el" href="structIR.html" title="The struct which represents an interval. ">IR</a> by a <a class="el" href="structU__IR.html" title="The struct which represents a union of intervals. ">U_IR</a>. </p>
<p>An <a class="el" href="structIR.html" title="The struct which represents an interval. ">IR</a> I is included in a <a class="el" href="structU__IR.html" title="The struct which represents a union of intervals. ">U_IR</a> U if I is contained in any <a class="el" href="structIR.html" title="The struct which represents an interval. ">IR</a> of U. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">I</td><td>the <a class="el" href="structIR.html" title="The struct which represents an interval. ">IR</a> to check. </td></tr>
    <tr><td class="paramname">U</td><td>the <a class="el" href="structU__IR.html" title="The struct which represents a union of intervals. ">U_IR</a> in which to search for I </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if I&lt;=U.S[i] for some i, false otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="aabfa1069209d27c327dd9960cbdbda58"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structIR.html">IR</a>&lt; R &gt; &amp;&#160;</td>
          <td class="paramname"><em>I1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structIR.html">IR</a>&lt; R &gt; &amp;&#160;</td>
          <td class="paramname"><em>I2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Equality operator for two <a class="el" href="structIR.html" title="The struct which represents an interval. ">IR</a>. </p>
<p>Two <a class="el" href="structIR.html" title="The struct which represents an interval. ">IR</a> are equal if their <a class="el" href="structIR.html#af9d1bea208e91beb8b3fd9bbd62655ff">IR::l</a> and <a class="el" href="structIR.html#a3f78c20104f8007d10068450dfef428b">IR::u</a> are equal between each other. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">I1</td><td>the first <a class="el" href="structIR.html" title="The struct which represents an interval. ">IR</a>. </td></tr>
    <tr><td class="paramname">I2</td><td>the second <a class="el" href="structIR.html" title="The struct which represents an interval. ">IR</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if two <a class="el" href="structIR.html" title="The struct which represents an interval. ">IR</a> are equal, false otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="af059a110629e403ca09be3c366f035d5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structU__IR.html">U_IR</a>&lt; R &gt; &amp;&#160;</td>
          <td class="paramname"><em>u_ir1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structU__IR.html">U_IR</a>&lt; R &gt; &amp;&#160;</td>
          <td class="paramname"><em>u_ir2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Equality operator for two <a class="el" href="structU__IR.html" title="The struct which represents a union of intervals. ">U_IR</a>. </p>
<p>Two <a class="el" href="structU__IR.html" title="The struct which represents a union of intervals. ">U_IR</a> are equal if their <a class="el" href="structU__IR.html#a883ee0578b3efb742f7680259f35646e">U_IR::S</a> are equal between each other. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u_ir1</td><td>the first <a class="el" href="structU__IR.html" title="The struct which represents a union of intervals. ">U_IR</a>. </td></tr>
    <tr><td class="paramname">u_ir2</td><td>the second <a class="el" href="structU__IR.html" title="The struct which represents a union of intervals. ">U_IR</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if two <a class="el" href="structU__IR.html" title="The struct which represents a union of intervals. ">U_IR</a> are equal, false otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="aa7d9c096caf494d6e0eb6a5d3bbf440c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structPR.html">PR</a>&lt; R &gt; &amp;&#160;</td>
          <td class="paramname"><em>point1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structPR.html">PR</a>&lt; R &gt; &amp;&#160;</td>
          <td class="paramname"><em>point2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Equality operator for two <a class="el" href="structPR.html" title="The struct which represents a point. ">PR</a>. </p>
<p>Two <a class="el" href="structPR.html" title="The struct which represents a point. ">PR</a> are equal if their <a class="el" href="structPR.html#a2676bb41b232def82358ae40311064a3">PR::x</a> are equal between each other. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">point1</td><td>the first <a class="el" href="structPR.html" title="The struct which represents a point. ">PR</a>. </td></tr>
    <tr><td class="paramname">pint2</td><td>the second <a class="el" href="structPR.html" title="The struct which represents a point. ">PR</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if two <a class="el" href="structPR.html" title="The struct which represents a point. ">PR</a> are equal, false otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="a29015a187a109737960c8f7a9c85b997"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structBR.html">BR</a>&lt; R &gt; &amp;&#160;</td>
          <td class="paramname"><em>box1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structBR.html">BR</a>&lt; R &gt; &amp;&#160;</td>
          <td class="paramname"><em>box2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Equality operator for two <a class="el" href="structBR.html" title="The struct which represents a box in R^d with d&gt;0, with inclusion order. ">BR</a>. </p>
<p>Two <a class="el" href="structBR.html" title="The struct which represents a box in R^d with d&gt;0, with inclusion order. ">BR</a> are equal if their <a class="el" href="structBR.html#a8e9cef9c38b306952fe679536962d868">BR::x</a> are equal between each other. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">box1</td><td>the first <a class="el" href="structBR.html" title="The struct which represents a box in R^d with d&gt;0, with inclusion order. ">BR</a>. </td></tr>
    <tr><td class="paramname">box2</td><td>the second <a class="el" href="structBR.html" title="The struct which represents a box in R^d with d&gt;0, with inclusion order. ">BR</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if two <a class="el" href="structBR.html" title="The struct which represents a box in R^d with d&gt;0, with inclusion order. ">BR</a> are equal, false otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="abae93ee5d606cca1963e31d02d5ba27a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a8ada4b9f0d00f81484f79ef9aa0fbe74">N</a> size </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structU__IR.html">U_IR</a>&lt; R &gt; &amp;&#160;</td>
          <td class="paramname"><em>u_ir</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that computes the size of the <a class="el" href="structU__IR.html" title="The struct which represents a union of intervals. ">U_IR</a> passed as input. </p>
<p>The size is computed by counting how many disjoint <a class="el" href="structIR.html" title="The struct which represents an interval. ">IR</a> form the union. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u_ir</td><td>The <a class="el" href="structU__IR.html" title="The struct which represents a union of intervals. ">U_IR</a> passed as input. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="types_8h.html#a8ada4b9f0d00f81484f79ef9aa0fbe74" title="Typedef for unsigned int.  It represents a link to a node/leaf inside DAG. ">N</a> The size of <a class="el" href="structU__IR.html#a883ee0578b3efb742f7680259f35646e">U_IR::S</a>. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
